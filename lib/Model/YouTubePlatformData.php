<?php
/**
 * YouTubePlatformData
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Late
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Late API
 *
 * API reference for Late. Authenticate with a Bearer API key. Base URL: https://getlate.dev/api
 *
 * The version of the OpenAPI document: 1.0.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.19.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Late\Model;

use \ArrayAccess;
use \Late\ObjectSerializer;

/**
 * YouTubePlatformData Class Doc Comment
 *
 * @category Class
 * @description YouTube video upload settings: - Videos ≤ 3 minutes are automatically detected as YouTube Shorts - Videos &gt; 3 minutes become regular YouTube videos - Custom thumbnails supported for regular videos (via mediaItem.thumbnail) - Custom thumbnails NOT supported for Shorts via API - Scheduled videos are uploaded immediately as the specified visibility and published at scheduled time - Visibility defaults to \&quot;public\&quot; if not specified - madeForKids defaults to false (not child-directed) - Set containsSyntheticMedia: true if your video contains AI-generated content
 * @package  Late
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class YouTubePlatformData implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'YouTubePlatformData';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'title' => 'string',
        'visibility' => 'string',
        'made_for_kids' => 'bool',
        'first_comment' => 'string',
        'contains_synthetic_media' => 'bool',
        'category_id' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'title' => null,
        'visibility' => null,
        'made_for_kids' => null,
        'first_comment' => null,
        'contains_synthetic_media' => null,
        'category_id' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'title' => false,
        'visibility' => false,
        'made_for_kids' => false,
        'first_comment' => false,
        'contains_synthetic_media' => false,
        'category_id' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'title' => 'title',
        'visibility' => 'visibility',
        'made_for_kids' => 'madeForKids',
        'first_comment' => 'firstComment',
        'contains_synthetic_media' => 'containsSyntheticMedia',
        'category_id' => 'categoryId'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'title' => 'setTitle',
        'visibility' => 'setVisibility',
        'made_for_kids' => 'setMadeForKids',
        'first_comment' => 'setFirstComment',
        'contains_synthetic_media' => 'setContainsSyntheticMedia',
        'category_id' => 'setCategoryId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'title' => 'getTitle',
        'visibility' => 'getVisibility',
        'made_for_kids' => 'getMadeForKids',
        'first_comment' => 'getFirstComment',
        'contains_synthetic_media' => 'getContainsSyntheticMedia',
        'category_id' => 'getCategoryId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const VISIBILITY__PUBLIC = 'public';
    public const VISIBILITY__PRIVATE = 'private';
    public const VISIBILITY_UNLISTED = 'unlisted';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getVisibilityAllowableValues()
    {
        return [
            self::VISIBILITY__PUBLIC,
            self::VISIBILITY__PRIVATE,
            self::VISIBILITY_UNLISTED,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('title', $data ?? [], null);
        $this->setIfExists('visibility', $data ?? [], 'public');
        $this->setIfExists('made_for_kids', $data ?? [], false);
        $this->setIfExists('first_comment', $data ?? [], null);
        $this->setIfExists('contains_synthetic_media', $data ?? [], false);
        $this->setIfExists('category_id', $data ?? [], '22');
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['title']) && (mb_strlen($this->container['title']) > 100)) {
            $invalidProperties[] = "invalid value for 'title', the character length must be smaller than or equal to 100.";
        }

        $allowedValues = $this->getVisibilityAllowableValues();
        if (!is_null($this->container['visibility']) && !in_array($this->container['visibility'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'visibility', must be one of '%s'",
                $this->container['visibility'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['first_comment']) && (mb_strlen($this->container['first_comment']) > 10000)) {
            $invalidProperties[] = "invalid value for 'first_comment', the character length must be smaller than or equal to 10000.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets title
     *
     * @return string|null
     */
    public function getTitle()
    {
        return $this->container['title'];
    }

    /**
     * Sets title
     *
     * @param string|null $title Video title. Defaults to first line of content or \"Untitled Video\". Must be ≤ 100 characters.
     *
     * @return self
     */
    public function setTitle($title)
    {
        if (is_null($title)) {
            throw new \InvalidArgumentException('non-nullable title cannot be null');
        }
        if ((mb_strlen($title) > 100)) {
            throw new \InvalidArgumentException('invalid length for $title when calling YouTubePlatformData., must be smaller than or equal to 100.');
        }

        $this->container['title'] = $title;

        return $this;
    }

    /**
     * Gets visibility
     *
     * @return string|null
     */
    public function getVisibility()
    {
        return $this->container['visibility'];
    }

    /**
     * Sets visibility
     *
     * @param string|null $visibility Video visibility setting: - public: Anyone can search for and watch (default) - unlisted: Only people with the link can watch - private: Only you and people you specifically share with can watch
     *
     * @return self
     */
    public function setVisibility($visibility)
    {
        if (is_null($visibility)) {
            throw new \InvalidArgumentException('non-nullable visibility cannot be null');
        }
        $allowedValues = $this->getVisibilityAllowableValues();
        if (!in_array($visibility, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'visibility', must be one of '%s'",
                    $visibility,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['visibility'] = $visibility;

        return $this;
    }

    /**
     * Gets made_for_kids
     *
     * @return bool|null
     */
    public function getMadeForKids()
    {
        return $this->container['made_for_kids'];
    }

    /**
     * Sets made_for_kids
     *
     * @param bool|null $made_for_kids COPPA compliance: Audience designation for the video. - true: Video is made for kids (child-directed content) - false: Video is NOT made for kids (default)  This field maps to YouTube's `selfDeclaredMadeForKids` setting. Videos marked as made for kids have restricted features (no comments, no notifications, limited ad targeting).  IMPORTANT: If not specified, defaults to false. YouTube requires this to be explicitly set, otherwise the video may be blocked from views until configured in YouTube Studio.
     *
     * @return self
     */
    public function setMadeForKids($made_for_kids)
    {
        if (is_null($made_for_kids)) {
            throw new \InvalidArgumentException('non-nullable made_for_kids cannot be null');
        }
        $this->container['made_for_kids'] = $made_for_kids;

        return $this;
    }

    /**
     * Gets first_comment
     *
     * @return string|null
     */
    public function getFirstComment()
    {
        return $this->container['first_comment'];
    }

    /**
     * Sets first_comment
     *
     * @param string|null $first_comment Optional first comment to post immediately after video upload. Up to 10,000 characters (YouTube's comment limit).
     *
     * @return self
     */
    public function setFirstComment($first_comment)
    {
        if (is_null($first_comment)) {
            throw new \InvalidArgumentException('non-nullable first_comment cannot be null');
        }
        if ((mb_strlen($first_comment) > 10000)) {
            throw new \InvalidArgumentException('invalid length for $first_comment when calling YouTubePlatformData., must be smaller than or equal to 10000.');
        }

        $this->container['first_comment'] = $first_comment;

        return $this;
    }

    /**
     * Gets contains_synthetic_media
     *
     * @return bool|null
     */
    public function getContainsSyntheticMedia()
    {
        return $this->container['contains_synthetic_media'];
    }

    /**
     * Sets contains_synthetic_media
     *
     * @param bool|null $contains_synthetic_media AI-generated content disclosure flag. Set to true if your video contains AI-generated or synthetic content that could be mistaken for real people, places, or events. This helps viewers understand when realistic content has been created or altered using AI. YouTube may add a label to videos when this is set. Added to YouTube Data API in October 2024.
     *
     * @return self
     */
    public function setContainsSyntheticMedia($contains_synthetic_media)
    {
        if (is_null($contains_synthetic_media)) {
            throw new \InvalidArgumentException('non-nullable contains_synthetic_media cannot be null');
        }
        $this->container['contains_synthetic_media'] = $contains_synthetic_media;

        return $this;
    }

    /**
     * Gets category_id
     *
     * @return string|null
     */
    public function getCategoryId()
    {
        return $this->container['category_id'];
    }

    /**
     * Sets category_id
     *
     * @param string|null $category_id YouTube video category ID. Defaults to '22' (People & Blogs). Common categories: 1 (Film & Animation), 2 (Autos & Vehicles), 10 (Music), 15 (Pets & Animals), 17 (Sports), 20 (Gaming), 22 (People & Blogs), 23 (Comedy), 24 (Entertainment), 25 (News & Politics), 26 (Howto & Style), 27 (Education), 28 (Science & Technology).
     *
     * @return self
     */
    public function setCategoryId($category_id)
    {
        if (is_null($category_id)) {
            throw new \InvalidArgumentException('non-nullable category_id cannot be null');
        }
        $this->container['category_id'] = $category_id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


